from typing import overload, SupportsIndex

from typediter.classes import Item_T
from typediter.classes.light import TypedTuple_lt
from typediter._helpers import check_object_compatibility


class TypedTuple( TypedTuple_lt[Item_T] ):
    """ Class based on tuple, insuring the type safety of its items, and the type safety on operations returning a new tuple

    It can be used exactly like the built-in tuple but its items, and some operations, are type-restricted,
    if the type restriction is broken, it fails with a TypeRestrictionError

    Inherits from tuple, but overriding methods:
        - That could insert an incompatible item (overridden in parent 'light' version class)
        - That used to return a tuple, to make it return a TypedTuple
        (for example, tuple addition returns a new tuple instance, so TypedTuple addition
        returns a new TypedTuple instance)

    Attributes
    ----------
    - **i_type**
        The type restriction for the items

    Raises
    ------
    - **typediter.exceptions.TypeRestrictionError**
        Raised by a typed-checked operation to prevent
        it from inserting incompatible items in a type-safe iterable.
        (Can be raised at instance creation
        or by every operation performing type checks)
    
    - **typediter.exceptions.InvalidTypeRestrictionError**
        Raised at instance creation if the provided 'i_type':
            - is not a type
    
    - **typediter.exceptions.IterableExpectedError**
        Raised by a type-checked operation if it expected an iterable
        but received something else
        (Can be raised at instance creation
        or by every operation performing type checks)
    
    - **other exceptions**
        Any exception that can be raised by a built-in 'tuple'
        for a given operation

    Usage Example
    -------------
    >>> # importing the class
    >>> from typediter import TypedTuple
    >>>
    >>> # creating an instance
    >>> string_tuple = TypedTuple( ('A', 'B', 'C'), i_type=str )
    >>>
    >>> # supports all tuple operations
    >>> new_tuple = string_tuple + ('D', 'E', 'F')
    >>>
    >>> # new instances generated by non-mutating
    >>> # operations are also type-safe
    >>> type( new_tuple ) # -> TypedTuple
    >>>
    >>> # Remark:
    >>> # if the non-mutating operation is handled by the built-in, a built-in is returned
    >>> builtin_tuple_addition = ('D', 'E', 'F') + string_tuple
    >>> type( builtin_tuple_addition ) # -> tuple
    >>>
    >>> # trying to insert an incompatible item in the instance,
    >>> # or in a typed iterable instance generated by an operation,
    >>> # will raise a TypeRestrictionError
    >>> invalid_instance = TypedTuple( ( 1, 2, 3 ), i_type=str ) # will raise TypeRestrictionError
    >>> invalid_operation_result = string_tuple + ( 1, 2, 3 ) # will raise TypeRestrictionError
    """
    __module__ = 'typediter.complete' # shorten class 'print' name

    # -------------------- Representation --------------------
    
    def __repr__( self ) -> str:
        typename = self.i_type.__name__
        default_representation = tuple(self)
        return f"Tuple[{typename}]:{default_representation}"

    # -------------------- Overriding --------------------
    # (mutating methods overridden in parent 'light' verion class) 
    # -> Operations handled by current class should return current class instance

    @overload
    def __getitem__( self, key: SupportsIndex, / ) -> Item_T: ...
    @overload
    def __getitem__( self, key: slice, / ) -> 'TypedTuple[Item_T]': ...
    def __getitem__( self, key: SupportsIndex | slice, / ) ->  Item_T | 'TypedTuple[Item_T]':
        """ (NO TYPE CHECKS NEEDED) Returns value for self[key]
        
        Returns:
        - for an index key: an item
        - for a slice key: a new typed tuple instance
        """
        if isinstance( key, slice):
            new_tuple = super().__getitem__( key )
            return TypedTuple( new_tuple, i_type=self.i_type, _skip_type_check=True )
        return super().__getitem__( key )

    def __add__( self, value: tuple[Item_T], / ) -> 'TypedTuple[Item_T]': #type: ignore[override]
        """ (TYPE-CHECKED) Return self+value as new typed tuple """
        check_object_compatibility( value, i_type=self.i_type )
        new_tuple = super().__add__( value )
        return TypedTuple( new_tuple, i_type=self.i_type, _skip_type_check=True )

    def __mul__( self, value: SupportsIndex, / ) -> 'TypedTuple[Item_T]':
        """ (NO TYPE CHECKS NEEDED) Return self*value as new typed tuple """
        new_tuple = super().__mul__( value )
        return TypedTuple( new_tuple, i_type=self.i_type, _skip_type_check=True )

    def __rmul__( self, value: SupportsIndex, / ) -> 'TypedTuple[Item_T]':
        """ (NO TYPE CHECKS NEEDED) Return value*self as new typed tuple """
        new_tuple = super().__rmul__( value )
        return TypedTuple( new_tuple, i_type=self.i_type, _skip_type_check=True )