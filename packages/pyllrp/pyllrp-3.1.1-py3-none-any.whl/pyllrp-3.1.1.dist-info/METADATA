Metadata-Version: 2.1
Name: pyllrp
Version: 3.1.1
Summary: A complete implementation of LLRP (Low Level Reader Protocol) in pure Python.
Home-page: http://www.sites.google.com/site/crossmgrsoftware/
Author: Edward Sitarski
Author-email: Edward Sitarski <edward.sitarski@gmail.com>
License: 
        Copyright (C) 2013-2019 Edward Sitarski
        
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
        and associated documentation files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use, copy, modify, merge, publish,
        distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all copies or
        substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
        BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        
Project-URL: Homepage, https://github.com/esitarski/pyllrp
Project-URL: Repository, https://github.com/esitarski/pyllrp
Project-URL: Issues, https://github.com/esitarski/pyllrp/issues
Keywords: LLRP,RFID,Impinj Reader
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Topic :: System :: Hardware :: Hardware Drivers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: bitstring >=3.1.1

# pyllrp

A 100% complete, pure Python implementation of LLRP (Low Level Reader Protocol) also with 100% support for Impinj extensions.

Communicate with LLRP-compliant RFID readers including Impinj, Alien and ThingMagic.
See the [LLRP spec](https://www.gs1.org/sites/default/files/docs/epc/llrp_1_0_1-standard-20070813.pdf) for full details.

__pyllrp__ supports quick-and-easy scripting in portable Python to
create LLRP applications.

It is used extensively in [CrossMgr](https://github.com/esitarski/CrossMgr) (CrossMgrImpinj and TagReadWrite) and [RaceDB](https://github.com/esitarski/RaceDB) for race timing.

All LLRP features and the full Impinj extension is supported:

* Message and Parameters are Python classes.
* 100% runtime validation of all LLRP Messages and Parameters including data types, data ranges, parameter sequence and count.
* 100% support for constant values - no hardcoded values necessary.
* Impossible to pass incorrect or malformed LLRP messages to the reader.

See TinyExample.py for how to use.

A reader connection manager is also included that can connect to a reader, transact commands,
and/or start/stop a thread to listen for tag reads.
A message handler callback can be configured to respond to reader messages in your code.

See wxExample.py for a simple method to show reader messages in
a wxPython application with a Queue (requires wxPython).

The module also supports reading and writing messages in XML format, however, I find it just as easy to create the messages in Python code.

pyllrp is picky about LLRP Messages, Parameters and data types.
For example, pyllrp passing ints as bools won't work; if the value must be True/False, 1/0 won't work.
The names of all non-default fields must be specified, with the exception of Parameters which have only one field.
In this case, the single parameter can be passed in the constructor.

## How to use it:

import pyllrp and follow the example.
TinyExample.py shows how to formulate LLRP specs, messages and parameters.
To run TinyExample, from the top pyllrp directory, enter "python3 -m pyllrp.TinyExample".


## How it works:

ParseDef.py reads the LLRP XML spec file and compiles it into a dict which it pretty-prints to a file called llrpdef.py.
ParseDef must be run every time the XML files change.

pyllrp.py imports llrpdef.py and converts the Messages, Parameters and Enums into runtime classes.
It adds the binary pack/unpack methods, data validation and human-readable formating functions to each class.
Startup time is minimal due to the llrpdef.py pre-processing, and this augementation is only done once.

Unlike other LLRP interfaces which sometimes combine messages and parameters into one call, pyllrp requires that you follow the LLRP spec accurately.
If in doubt, check the LLRP spec and follow it exactly.

## Future work:

Because the classes are created dynamically, python linters (eg. flake8) create lots of warnings for __pyllrp__ calls.
This could be migitated by code generating the full classes in llrpdef.py.
But, this is likely slower and less memory efficient than the current approach.
