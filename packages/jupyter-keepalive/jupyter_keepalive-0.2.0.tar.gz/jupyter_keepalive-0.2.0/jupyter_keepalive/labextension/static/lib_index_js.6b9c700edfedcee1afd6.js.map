{"version":3,"file":"lib_index_js.6b9c700edfedcee1afd6.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAA2C;AACF;AACkC;AACxB;AACJ;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,qBAAqB,kEAAgB;AACrC,uBAAuB,yDAAM;AAC7B;AACA;AACA,yBAAyB,kEAAgB;AACzC;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE;AACzB;AACA;AACA;AACA,kBAAkB,EAAE;AACpB;AACA;AACA;AACA,kBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0CAA0C,mDAAM;AAChD;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA,wCAAwC,iCAAiC,uCAAuC,mCAAmC;AACnJ,mGAAmG,eAAe;AAClH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,SAAS;AACT;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAU;AACvC;AACA;AACA;AACA;AACA,gBAAgB,wDAAM;AACtB,gBAAgB,wDAAM,YAAY,qBAAqB;AACvD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAU;AACzB,eAAe,iEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAsC;AACpE;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,SAAS,EAAC","sources":["webpack://@minrk/jupyter-keepalive/./lib/index.js"],"sourcesContent":["import { Signal } from \"@lumino/signaling\";\nimport { Widget } from \"@lumino/widgets\";\nimport { Dialog, showDialog, ICommandPalette } from \"@jupyterlab/apputils\";\nimport { IStatusBar } from \"@jupyterlab/statusbar\";\nimport { URLExt } from \"@jupyterlab/coreutils\";\nimport { ServerConnection } from \"@jupyterlab/services\";\n// import \"./index.css\";\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nasync function keepAliveRequest(endPoint = \"\", init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, \"ext-keepalive\", endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    const responseJSON = await response.text();\n    if (responseJSON.length == 0) {\n        return;\n    }\n    const data = JSON.parse(responseJSON);\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message);\n    }\n    return data;\n}\nconst DAY_SECONDS = 24 * 60 * 60;\nconst hmsPattern = /^(?:(?<days>\\d+):(?=\\d+:))?(?:(?<hours>\\d+):)?(?<seconds>\\d+)$/;\nconst abbrevPattern = /^(?:(?<days>\\d+)d)?(?:(?<hours>\\d+)h)?(?:(?<minutes>\\d+)m)?(?:(?<seconds>\\d+)s?)?$/;\nconst multipliers = {\n    minutes: 60,\n    hours: 60 * 60,\n    days: 24 * 60 * 60,\n    seconds: 1,\n};\nfunction parseTime(ts) {\n    let seconds = 0;\n    let match = hmsPattern.exec(ts);\n    if (!match) {\n        match = abbrevPattern.exec(ts);\n    }\n    if (!match) {\n        throw Error(`time string '${ts}' as a time. Expected e.g. '1:30' or '120m'`);\n    }\n    let part;\n    for (part in multipliers) {\n        if (match.groups[part] !== undefined) {\n            seconds += multipliers[part] * parseInt(match.groups[part]);\n        }\n    }\n    return seconds;\n}\nfunction formatSeconds(seconds) {\n    console.log(\"formatting\", seconds);\n    if (seconds < 60) {\n        return `${seconds}s`;\n    }\n    else if (seconds < 120) {\n        const m = Math.floor(seconds / 60);\n        const s = seconds % 60;\n        return `${m}m${s}s`;\n    }\n    else if (seconds < 3600) {\n        const m = Math.floor(seconds / 60);\n        return `${m}m`;\n    }\n    else {\n        const h = Math.round(seconds / 3600);\n        return `${h}h`;\n    }\n}\nclass KeepAliveExtension {\n    constructor() {\n        this.remainingSignal = new Signal(this);\n        this.remainingSignal.connect(this.scheduleUpdate);\n        this.remaining = 0;\n    }\n    scheduleUpdate(sender, remaining) {\n        // keep widgets updated at an appropriate in\n        sender.remaining = remaining;\n        if (!remaining) {\n            return;\n        }\n        let timeout = 0;\n        if (remaining < 60) {\n            timeout = 1;\n        }\n        else if (remaining < 120) {\n            // every 2 seconds if we're within 2 minutes\n            timeout = 2;\n        }\n        else if (remaining < 60) {\n            // every minute if we're within an hour\n            timeout = 60;\n        }\n        else {\n            // at least every 5 minutes\n            timeout = 300;\n        }\n        setTimeout(() => {\n            sender.getRemaining();\n        }, timeout * 1000);\n    }\n    setupStatusBar(statusBar) {\n        const keepAliveStatusWidget = new Widget();\n        this.remainingSignal.connect((sender, remaining) => {\n            if (remaining) {\n                const remaining_text = formatSeconds(remaining);\n                keepAliveStatusWidget.node.textContent = \"\";\n                const span = document.createElement(\"span\");\n                span.textContent = `Keepalive: ${remaining_text}`;\n                // TODO: import css?\n                // css is copied from TextItem, but using TextItem is incredibly complicated apparently\n                span.style.cssText =\n                    \"line-height: 24px; color: var(--jp-ui-font-color1); font-family: var(--jp-ui-font-family); font-size: var(--jp-ui-font-size1);\";\n                keepAliveStatusWidget.node.title = `Jupyter Server will not appear idle idle for ${remaining_text}`;\n                keepAliveStatusWidget.node.appendChild(span);\n            }\n            else {\n                keepAliveStatusWidget.node.textContent = \"Keepalive: inactive\";\n            }\n        });\n        statusBar.registerStatusItem(\"keepalive\", {\n            align: \"left\",\n            item: keepAliveStatusWidget,\n            isActive: () => true // Always actice\n        });\n    }\n    async start(seconds = DAY_SECONDS) {\n        const keepAliveData = await keepAliveRequest(\"\", {\n            method: \"POST\",\n            body: JSON.stringify({ seconds: seconds }),\n        });\n        this.remainingSignal.emit(keepAliveData.remaining);\n    }\n    async stop() {\n        await keepAliveRequest(\"\", { method: \"DELETE\" });\n        this.remainingSignal.emit(0);\n    }\n    async getRemaining() {\n        const keepAliveData = await keepAliveRequest(\"\");\n        this.remainingSignal.emit(keepAliveData.remaining);\n        return keepAliveData.remaining;\n    }\n    async startDialog() {\n        const result = await showDialog({\n            title: \"Keep Jupyter server alive\",\n            body: new KeepAliveDialogBody(),\n            focusNodeSelector: \"input\",\n            buttons: [\n                Dialog.cancelButton(),\n                Dialog.okButton({ label: \"Keep alive\" }),\n            ],\n        });\n        if (!result.value) {\n            return;\n        }\n        const t = parseTime(result.value);\n        await this.start(t);\n    }\n}\nclass KeepAliveDialogBody extends Widget {\n    /**\n     * Construct a new keep alive dialog.\n     */\n    constructor() {\n        const body = document.createElement(\"div\");\n        const description = document.createElement(\"p\");\n        description.textContent =\n            \"Keep Jupyter Server from shutting down due to idle culling for a period of time. \\\n      Use abbreviated notation such as '2d' for two days, \\\n      '3h45m' for 3 hours and 45 minutes, \\\n      or seconds as an integer (900).\";\n        const label = document.createElement(\"label\");\n        label.textContent = \"Duration\";\n        const input = document.createElement(\"input\");\n        input.placeholder = \"24h\";\n        input.value = \"24h\";\n        body.appendChild(description);\n        body.appendChild(label);\n        body.appendChild(input);\n        super({ node: body });\n    }\n    /**\n     * Get the input text node.\n     */\n    get inputNode() {\n        return this.node.getElementsByTagName(\"input\")[0];\n    }\n    /**\n     * Get the value of the widget.\n     */\n    getValue() {\n        return this.inputNode.value;\n    }\n}\n/**\n * Initialization data for the extension.\n */\nconst extension = {\n    id: \"jupyter-keepalive\",\n    autoStart: true,\n    optional: [IStatusBar],\n    requires: [ICommandPalette],\n    activate: async (app, palette, statusBar) => {\n        console.log(\"JupyterLab extension keepalive is activated!\");\n        const keepAlive = new KeepAliveExtension();\n        if (statusBar) {\n            keepAlive.setupStatusBar(statusBar);\n        }\n        const { commands } = app;\n        const category = \"Keepalive\";\n        commands.addCommand(\"keepalive:start\", {\n            label: \"Keep server alive while idle (24h)\",\n            caption: \"Registers activity so idle cullers don't shut this server down, for `seconds`.\",\n            execute: (args) => {\n                let seconds;\n                if (typeof args.seconds === \"number\") {\n                    seconds = args.seconds;\n                }\n                else if (typeof args.seconds === \"string\") {\n                    seconds = parseTime(args.seconds);\n                }\n                else {\n                    seconds = DAY_SECONDS;\n                }\n                keepAlive.start(seconds);\n            },\n        });\n        commands.addCommand(\"keepalive:start-dialog\", {\n            label: \"Keep server alive while idle (dialog)\",\n            caption: \"Registers activity so idle cullers don't shut this server down.\",\n            execute: () => {\n                keepAlive.startDialog();\n            },\n        });\n        commands.addCommand(\"keepalive:stop\", {\n            label: \"Stop keeping server alive\",\n            caption: \"Stop the keepalive spinner\",\n            execute: () => {\n                keepAlive.stop();\n            },\n        });\n        commands.addCommand(\"keepalive:check\", {\n            label: \"Check keepalive status\",\n            caption: \"Check the remaining time on the keepalive timer\",\n            execute: () => {\n                keepAlive.getRemaining();\n                // todo: display it somehow\n            },\n        });\n        for (const command of [\n            \"keepalive:start\",\n            \"keepalive:start-dialog\",\n            \"keepalive:stop\",\n            \"keepalive:check\",\n        ]) {\n            palette.addItem({ command: command, category: category });\n        }\n        await keepAlive.getRemaining();\n        return keepAlive;\n    },\n};\nexport default extension;\n"],"names":[],"sourceRoot":""}