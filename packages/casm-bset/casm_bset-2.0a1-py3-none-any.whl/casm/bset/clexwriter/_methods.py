import pathlib
import re
from typing import Optional

import jinja2
from sortedcontainers import SortedList

import libcasm.clusterography as casmclust
import libcasm.configuration as casmconfig
import libcasm.xtal as xtal
from casm.bset.clexwriter import (
    CppFormatProperties,
    occ_delta_site_bfunc_cpp_str,
    orbit_bfunc_cpp_str,
    site_bfunc_cpp_str,
)
from casm.bset.cluster_functions import (
    ClexBasisSpecs,
    ClusterFunctionsBuilder,
    get_occ_site_functions,
    make_local_point_functions,
    make_point_functions,
)
from casm.bset.polynomial_functions import (
    PolynomialFunction,
)
from libcasm.clexulator import (
    PrimNeighborList,
)


def make_neighborhoods(
    is_periodic: bool,
    prim_neighbor_list: PrimNeighborList,
    clusters: list[list[casmclust.Cluster]],
    functions: list[list[list[PolynomialFunction]]],
    linear_function_indices: Optional[set[int]] = None,
):
    """Make the neighborhood lists for the functions

    Parameters
    ----------
    is_periodic: bool
        Whether the Clexulator is for a periodic basis set or local basis set.

    prim_neighbor_list: libcasm.clexulator.PrimNeighborList
        :class:`~libcasm.clexulator.PrimNeighborList`, containing all the neighbors
        needed for evaluation, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`.

    clusters: list[list[libcasm.clusterography.Cluster]]
        List of clusters, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`. Site order
        must be consistent with `functions`.

    functions: list[list[list[casm.bset.polynomial_functions.PolynomialFunction]]]
        List of functions, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`, where
        ``functions[i_orbit][i_equiv][i_func]``,
        is the `i_func`-th function on the cluster given by
        `clusters[i_orbit][i_equiv]`.

    linear_function_indices : Optional[set[int]]
        The linear indices of the functions that will be included. If None,
        all functions will be included in the Clexulator. Otherwise,
        only the specified functions will be included in the Clexulator


    Returns
    -------
    complete_neighborhood: dict
        The complete neighborhood of the basis functions. Contains:

        - ``"unitcells"``: list[list[int]], List of ``[i,j,k]`` unit
          cell indices for the neighborhood of the orbit of basis function.
        - ``"sites"``: list[list[int]], List of ``[b,i,j,k]`` site
          indices for the neighborhood of the orbit of basis function.

    function_neighborhoods: list[dict]
        The neighborhood data for each orbit of basis functions. Each dictionary
        contains:

        - ``"linear_function_index"``: int, Linear function index
        - ``"same_as"``: Optional[int], If not None, the linear function index of the
          first orbit of functions in the same cluster orbit as this function, which
          has the same neighborhood.
        - ``"unitcells"``: list[list[int]], List of ``[i,j,k]`` unit
          cell indices for the neighborhood of the orbit of basis function. This is
          only populated for the first function in each cluster orbit.
        - ``"sites"``: list[list[int]], List of ``[b,i,j,k]`` site
          indices for the neighborhood of the orbit of basis function. This is
          only populated for the first function in each cluster orbit.
    """

    # get total number of basis functions
    n_corr = 1  # include constant term
    for i_orbit, orbit_functions in enumerate(functions):
        prototype_functions = orbit_functions[0]
        n_corr += len(prototype_functions)

    # make neighborhood index -> site lookup
    neighborhood_index_to_site = []
    for unitcell in prim_neighbor_list:
        for sublattice_index in prim_neighbor_list.sublattice_indices():
            integral_site_coordinate = xtal.IntegralSiteCoordinate(
                sublattice=sublattice_index,
                unitcell=unitcell,
            )
            neighborhood_index_to_site.append(integral_site_coordinate)

    function_neighborhoods = []
    for i_func in range(n_corr):
        function_neighborhoods.append(
            {
                "linear_function_index": i_func,
                "same_as": None,
                "unitcells": SortedList(),
                "sites": SortedList(),
            }
        )

    # the constant function is not included in `functions`
    linear_function_index_sum = 1
    for i_orbit, orbit_functions in enumerate(functions):
        # This is orbit_functions[i_equiv][i_func]
        # We want: orbit_equiv_functions[i_func][j], where i_func indicates
        # symmetrically equivalent functions and j is an index over all
        # symmetrically equivalent functions associated with the origin unit cell

        # For periodic:
        # - Get all functions that include sites in the origin unit cell (i.e. add
        #   translational equivalents if they involve sites in the origin unit cell)
        # - Then organize by i_func on prototype -> all equivalent functions
        # For local:
        # - Just re-organize by i_func on prototype -> all equivalent functions

        if is_periodic:
            # point_functions: list[list[list[PolynomialFunction]]]
            #     All point functions for this cluster orbit, for each point corr site
            #     point_functions[i_func][nlist_index][i_point_function]
            point_functions = make_point_functions(
                prim_neighbor_list=prim_neighbor_list,
                orbit=clusters[i_orbit],
                orbit_functions=orbit_functions,
            )

            # Note: point_functions contains duplicates, but that's OK for generating
            # the neighborhood

            # orbit_equiv_functions: list[list[PolynomialFunction]]
            #     All functions for this cluster orbit,
            #     orbit_equiv_functions[i_func][i_equiv_function]
            orbit_equiv_functions = []
            for i_func, functions_by_nbor in enumerate(point_functions):
                x = []
                for funcs in functions_by_nbor:
                    x += funcs
                orbit_equiv_functions.append(x)

        else:
            # orbit_equiv_functions: list[list[PolynomialFunction]]
            #     All point functions for this cluster orbit,
            #     orbit_equiv_functions[i_func][i_equiv_function]
            prototype_basis_set = orbit_functions[0]
            orbit_equiv_functions = [[]] * len(prototype_basis_set)

            for i_equiv, equiv_functions in enumerate(orbit_functions):
                for i_func, f in enumerate(equiv_functions):
                    orbit_equiv_functions[i_func].append(f)

        for i_func, equiv_functions in enumerate(orbit_equiv_functions):
            linear_function_index = linear_function_index_sum + i_func

            if (
                linear_function_indices is not None
                and linear_function_index not in linear_function_indices
            ):
                continue

            if i_func != 0:
                function_neighborhoods[linear_function_index][
                    "same_as"
                ] = linear_function_index_sum
                continue

            for func in equiv_functions:
                for var in func.variables:
                    # skip global variables:
                    if var.neighborhood_site_index is None:
                        continue

                    site = neighborhood_index_to_site[var.neighborhood_site_index]

                    site_as_list = site.to_list()
                    unitcell_as_list = site.unitcell().tolist()

                    f_neighborhood = function_neighborhoods[linear_function_index]
                    f_unitcell_nbors = f_neighborhood["unitcells"]
                    f_site_nbors = f_neighborhood["sites"]

                    if unitcell_as_list not in f_unitcell_nbors:
                        f_unitcell_nbors.add(unitcell_as_list)

                    if site_as_list not in f_site_nbors:
                        f_site_nbors.add(site_as_list)

        linear_function_index_sum += len(orbit_functions[0])

    complete_neighborhood = {
        "unitcells": SortedList(),
        "sites": SortedList(),
    }
    for d in function_neighborhoods:
        d["unitcells"] = list(d["unitcells"])
        d["sites"] = list(d["sites"])

        for unitcell in d["unitcells"]:
            if unitcell not in complete_neighborhood["unitcells"]:
                complete_neighborhood["unitcells"].add(unitcell)

        for site in d["sites"]:
            if site not in complete_neighborhood["sites"]:
                complete_neighborhood["sites"].add(site)
    complete_neighborhood["unitcells"] = list(complete_neighborhood["unitcells"])
    complete_neighborhood["sites"] = list(complete_neighborhood["sites"])

    return (complete_neighborhood, function_neighborhoods)


def _add_variables_needed(
    data: dict[str, list],
    functions: list[PolynomialFunction],
    prim_neighbor_list: PrimNeighborList,
    occ_site_functions: list[list[float]],
):
    nlist_sublat_indices = prim_neighbor_list.sublattice_indices()
    for f in functions:
        for var in f.variables:
            if var.key not in data:
                data[var.key] = []
            # continuous DoF
            n = var.neighborhood_site_index
            if n is None:
                b = None
            else:
                i = var.neighborhood_site_index % len(nlist_sublat_indices)
                b = nlist_sublat_indices[i]
            if var.key == "occ":
                # skip constant occupation functions
                phi = get_occ_site_functions(
                    occ_site_functions=occ_site_functions,
                    sublattice_index=b,
                    site_function_index=var.site_basis_function_index,
                )

                if (phi == 1.0).all():
                    continue

                # occ DoF / site basis function
                value = [var.site_basis_function_index, n, b]
            else:
                value = [var.component_index, n, b]
            if value not in data[var.key]:
                data[var.key].append(value)


def make_orbit_bfuncs(
    prim_neighbor_list: PrimNeighborList,
    clusters: list[list[casmclust.Cluster]],
    functions: list[list[list[PolynomialFunction]]],
    occ_site_functions: list[dict],
    cpp_fmt: CppFormatProperties,
    linear_function_indices: Optional[set[int]] = None,
) -> tuple[list[dict], dict[str, list[list[int]]]]:
    """Convert clusters and functions to data used by Jinja templates to write the \
    orbit basis function evaluating methods (i.e. the contributions to the global \
    correlations from one unit cell).

    Parameters
    ----------
    prim_neighbor_list: libcasm.clexulator.PrimNeighborList
        :class:`~libcasm.clexulator.PrimNeighborList`, containing all the neighbors
        needed for evaluation, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`.

    clusters: list[list[libcasm.clusterography.Cluster]]
        List of clusters, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`. Site order
        must be consistent with `functions`.

    functions: list[list[list[casm.bset.polynomial_functions.PolynomialFunction]]]
        List of functions, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`.

    occ_site_functions: list[dict]
        List of occupation site basis functions. For each sublattice with discrete
        site basis functions, must include:

        - `"sublattice_index"`: int, index of the sublattice
        - `"value"`: list[list[float]], list of the site basis function values, as
          ``value = functions[function_index][occupant_index]``.

    cpp_fmt: CppFormatProperties
        C++ string formatting properties. If None, the default values are used.

    linear_function_indices : Optional[set[int]]
        The linear indices of the functions that will be included. If None,
        all functions will be included in the Clexulator. Otherwise,
        only the specified functions will be included in the Clexulator


    Returns
    -------
    orbit_bfuncs: list[dict]
        Data for each orbit basis function (i.e. the contribution to the global
        correlations from one unit cell). Includes:

        - ``"linear_function_index"``: int, Linear function index
        - ``"linear_orbit_index"``: int, Linear cluster orbit index
        - ``"cpp"``: str, C++ expression for evaluating the global correlation
          contribution
        - ``"latex_prototype"``: str, Latex formula for the prototype
        - ``latex_orbit"``: str, Latex formula for the orbit contribution

    variables_needed: dict[str,list[list[int]]]
        The variables needed to evaluate the orbit basis functions. The dictionary keys
        are DoF type key, and values are lists of
        [`component_index`, `neighbor_list_index`, `sublattice_index`] for variables
        of that type. The `neighbor_list_index` and `sublattice_index` for global
        continuous DoF are None.

    """
    linear_function_index = 0
    linear_orbit_index = 0
    orbit_bfuncs = []
    variables_needed = {}

    # For constant term, linear_function_index==0:
    if (
        linear_function_indices is None
        or linear_function_index in linear_function_indices
    ):
        orbit_bfuncs.append(
            {
                "linear_function_index": linear_function_index,
                "linear_orbit_index": linear_orbit_index,
                "cpp": "1",
                "latex_prototype": "1",
                "latex_orbit": "1",
            }
        )
    linear_function_index += 1

    ### For all cluster orbits (includes null cluster):
    # i_orbit: cluster orbit index
    # orbit: list[Cluster]
    for i_orbit, orbit in enumerate(clusters):
        # i_func: cluster function index
        # f_prototype: i_func-th function on prototype cluster
        for i_func, f_prototype in enumerate(functions[i_orbit][0]):
            # Allow filtering by linear_function_index
            if (
                linear_function_indices is None
                or linear_function_index in linear_function_indices
            ):
                # orbit_functions: i_func-th function on each cluster in orbit
                orbit_functions = [
                    functions_by_cluster[i_func]
                    for functions_by_cluster in functions[i_orbit]
                ]
                _add_variables_needed(
                    data=variables_needed,
                    functions=orbit_functions,
                    prim_neighbor_list=prim_neighbor_list,
                    occ_site_functions=occ_site_functions,
                )

                orbit_bfuncs.append(
                    # make global correlation contribution formulas
                    {
                        "linear_function_index": linear_function_index,
                        "linear_orbit_index": linear_orbit_index,
                        "cpp": orbit_bfunc_cpp_str(
                            orbit_functions=orbit_functions,
                            orbit_size=len(orbit_functions),
                            prim_neighbor_list=prim_neighbor_list,
                            cpp_fmt=cpp_fmt,
                        ),
                        "latex_prototype": "<todo>",
                        "latex_orbit": "<todo>",
                    }
                )
            linear_function_index += 1
        linear_orbit_index += 1
    return (orbit_bfuncs, variables_needed)


def _make_site_bfuncs_data(
    linear_function_index: int,
    linear_orbit_index: int,
    equiv_functions: list[list[PolynomialFunction]],
    orbit_size: int,
    prim_neighbor_list: PrimNeighborList,
    cpp_fmt: CppFormatProperties,
) -> dict:
    data = {
        "linear_function_index": linear_function_index,
        "linear_orbit_index": linear_orbit_index,
        "at": [],
    }
    for neighbor_list_index, equiv_functions_by_point in enumerate(equiv_functions):
        data["at"].append(
            {
                "neighbor_list_index": neighbor_list_index,
                "n_point_functions": len(equiv_functions_by_point),
                "cpp": site_bfunc_cpp_str(
                    point_functions=equiv_functions_by_point,
                    orbit_size=orbit_size,
                    prim_neighbor_list=prim_neighbor_list,
                    cpp_fmt=cpp_fmt,
                ),
                "latex_prototype": "<todo>",
                "latex_orbit": "<todo>",
                "occ_delta_cpp": occ_delta_site_bfunc_cpp_str(
                    neighbor_list_index=neighbor_list_index,
                    point_functions=equiv_functions_by_point,
                    orbit_size=orbit_size,
                    prim_neighbor_list=prim_neighbor_list,
                    cpp_fmt=cpp_fmt,
                ),
            }
        )
    return data


def make_site_bfuncs(
    is_periodic: bool,
    prim_neighbor_list: PrimNeighborList,
    clusters: list[list[casmclust.Cluster]],
    functions: list[list[list[PolynomialFunction]]],
    occ_site_functions: list[dict],
    cpp_fmt: CppFormatProperties,
    linear_function_indices: Optional[set[int]] = None,
) -> tuple[list[dict], list[dict[str, list[list[int]]]]]:
    """Convert clusters and functions to data used by Jinja templates to write the \
    point correlation evaluating methods.

    Notes
    -----

    - For local basis sets, this currently returns empty lists

    Parameters
    ----------
    is_periodic: bool
        Whether the Clexulator is for a periodic basis set or local basis set.
    prim_neighbor_list: libcasm.clexulator.PrimNeighborList
        :class:`~libcasm.clexulator.PrimNeighborList`, containing all the neighbors
        needed for evaluation, as obtained from
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`.
    clusters: list[list[libcasm.clusterography.Cluster]]
        List of clusters, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`. Site order
        must be consistent with `functions`.
    functions: list[list[list[casm.bset.polynomial_functions.PolynomialFunction]]]
        List of functions, as generated by
        :class:`~casm.bset.cluster_functions.ClusterFunctionBuilder`.
    occ_site_functions: list[dict]
        List of occupation site basis functions. For each sublattice with discrete
        site basis functions, must include:

        - `"sublattice_index"`: int, index of the sublattice
        - `"value"`: list[list[float]], list of the site basis function values, as
          ``value = functions[function_index][occupant_index]``.

    cpp_fmt: CppFormatProperties
        C++ string formatting properties. If None, the default values are used.
    linear_function_indices : Optional[set[int]]
        The linear indices of the functions that will be included. If None,
        all functions will be included in the Clexulator. Otherwise,
        only the specified functions will be included in the Clexulator

    Returns
    -------
    site_bfuncs_data: list[dict]
        List of dictionaries, one per cluster expansion basis function, with information
        needed for printing the Clexulator point correlation evaluation methods.
        The format is:

        - "linear_function_index": int - The cluster expansion basis function index.
        - "linear_orbit_index": int - The cluster orbit index
        - "at": list[dict] - Data for functions at specific points

          - "neighbor_list_index": int - Index into the neighbor list of the point
          - "cpp": str - The C++ code to evaluate the point functions
          - "occ_delta_cpp": str - The C++ code to evaluate the change in point
            functions due to the change of occupation index on the site from
            ``"occ_i"`` to ``"occ_f"``.
          - "latex_prototype": str - The latex expression for the point functions,
            including only functions from the prototype cluster
          - "latex_orbit": str - The latex expression for the point functions,
            including functions from the entire cluster orbit

    variables_needed_at: list[dict[str,list[list[int]]]]
        For each point, the variables needed to evaluate the point functions. The value
        of `variables_needed_at[neighbor_list_index]` is a dictionary, where the keys
        are DoF type key, and values are lists of
        [`component_index`, `neighbor_list_index`, `sublattice_index`] for variables
        of that type. The `neighbor_list_index` and `sublattice_index` for global
        continuous DoF are None.
    """

    # set n_point_corr_sites_max
    if is_periodic:
        n_point_corr_sites_max = len(prim_neighbor_list.sublattice_indices())
    else:
        n_point_corr_sites_max = prim_neighbor_list.n_neighborhood_sites()

    ### Start: constant term, linear_function_index==0 ###
    linear_function_index = 0
    linear_orbit_index = 0
    site_bfuncs = []
    variables_needed_at = [{} for i in range(n_point_corr_sites_max)]

    ### For constant term, linear_function_index==0:
    # Allow filtering by linear_function_index
    if (
        linear_function_indices is None
        or linear_function_index in linear_function_indices
    ):
        site_bfuncs.append(
            {
                "linear_function_index": linear_function_index,
                "linear_orbit_index": linear_orbit_index,
                "at": [],
            }
        )

    linear_function_index += 1

    ### For all cluster orbits (includes null cluster):
    # i_orbit: cluster orbit index
    # orbit: list[Cluster]
    for i_orbit, orbit in enumerate(clusters):
        # point_functions: list[list[list[PolynomialFunction]]]
        #     All point functions for this cluster orbit, for each point corr site
        #     point_functions[i_func][nlist_index][i_point_function]
        if is_periodic:
            # take global functions (non-duplicating) and make all point functions
            point_functions = make_point_functions(
                prim_neighbor_list=prim_neighbor_list,
                orbit=orbit,
                orbit_functions=functions[i_orbit],
            )
        else:
            point_functions = make_local_point_functions(
                prim_neighbor_list=prim_neighbor_list,
                orbit=orbit,
                orbit_functions=functions[i_orbit],
            )

        # i_func: cluster function index
        # equiv_functions: list[list[PolynomialFunction]]
        #     All equivalent point functions, for each point corr site
        #     equiv_functions[nlist_index][i_point_function]
        for i_func, equiv_functions in enumerate(point_functions):
            # Allow filtering by linear_function_index
            if (
                linear_function_indices is None
                or linear_function_index in linear_function_indices
            ):
                for neighbor_list_index, equiv_functions_by_point in enumerate(
                    equiv_functions
                ):
                    _add_variables_needed(
                        data=variables_needed_at[neighbor_list_index],
                        functions=equiv_functions_by_point,
                        prim_neighbor_list=prim_neighbor_list,
                        occ_site_functions=occ_site_functions,
                    )

                site_bfuncs.append(
                    # make point correlation formulas for each point corr site
                    _make_site_bfuncs_data(
                        linear_function_index=linear_function_index,
                        linear_orbit_index=linear_orbit_index,
                        equiv_functions=equiv_functions,
                        orbit_size=len(orbit),
                        prim_neighbor_list=prim_neighbor_list,
                        cpp_fmt=cpp_fmt,
                    )
                )
            linear_function_index += 1
        linear_orbit_index += 1
    return (site_bfuncs, variables_needed_at)


class ClexulatorWriter:
    """Write Clexulator source files and related files"""

    def __init__(
        self,
        bset_dir: pathlib.Path,
        version: str,
        project_name: str,
        bset_name: str,
        linear_function_indices: Optional[set[int]] = None,
        cpp_fmt: Optional[CppFormatProperties] = None,
    ):
        """

        .. rubric:: Constructor

        Parameters
        ----------
        bset_dir: pathlib.Path
            The path to the basis set directory where the Clexulator and related files
            should be written

        version: str
            The Clexulator version to write. One of:

            - "v1.basic": Standard CASM v1 compatible Clexulator, without automatic
              differentiation
            - "v1.diff": (TODO) CASM v1 compatible Clexulator, with ``fadbad`` automatic
              differentiation enabled

        project_name: str
            Project name. Used to construct the Clexulator class name. This must
            consist of alphanumeric characters and underscores only. The first
            character may not be a number.

        bset_name: str
            Basis set name. Used to construct the Clexulator class name. This must
            consist of alphanumeric characters and underscores only.

        linear_function_indices : Optional[set[int]]
            The linear indices of the functions that will be included. If None,
            all functions will be included in the Clexulator. Otherwise,
            only the specified functions will be included in the Clexulator.
            Generally this is not known the first time a Clexulator is generated, but
            after fitting coefficients it may be used to re-generate the Clexulator
            with the subset of the basis functions needed.

        cpp_fmt: Optional[CppFormatProperties] = None,
            C++ string formatting properties. If None, the default values are used.

        """
        self.bset_dir = pathlib.Path(bset_dir)
        """pathlib.Path: The path to the basis set directory where the Clexulator and \
        related files should be written."""

        self.version = version
        """str: The Clexulator version to write. 
        
        One of:
        
        - "v1.basic": Standard CASM v1 compatible Clexulator, without automatic
            differentiation.
        - "v1.diff": (TODO) CASM v1 compatible Clexulator, with ``fadbad`` automatic
            differentiation enabled.
        
        """

        self.project_name = project_name
        """str: Project name."""

        self.bset_name = bset_name
        """str: Basis set name. 
        
        Used to construct the Clexulator class name. This must consist of alphanumeric 
        characters and underscores only."""

        self.linear_function_indices = linear_function_indices
        """Optional[set[int]]: The linear indices of the functions that will be \
        included."""

        self.cpp_fmt = cpp_fmt
        """Optional[CppFormatProperties]: C++ string formatting properties. If None, \
        the default values are used."""

        self.src_path = None
        """Optional[pathlib.Path]: The path to the Clexulator source file, once \
        written."""

        self.local_src_path = None
        """Optional[list[pathlib.Path]]: The paths to the local Clexulator source \
        files, once written."""

        if not re.match(
            R"^[a-zA-Z_]+\w*",
            project_name,
        ):
            raise Exception(
                f"project_name='{project_name}' is not valid: ",
                "Must consist alphanumeric characters and underscores only. "
                "The first character may not be a number.",
            )
        if not re.match(
            R"^\w+",
            bset_name,
        ):
            raise Exception(
                f"bset_name='{bset_name}' is not valid: ",
                "Must consist alphanumeric characters and underscores only.",
            )

        if self.version == "v1.basic":
            from ._write_v1_basic import WriterV1Basic

            self.writer_type = WriterV1Basic
        else:
            raise Exception(f"Error in ClexulatorWriter: Unknown version '{version}'")

    def write(
        self,
        prim: casmconfig.Prim,
        clex_basis_specs: ClexBasisSpecs,
        prim_neighbor_list: PrimNeighborList,
    ):
        """Write Clexulator source files and related files

        Parameters
        ----------
        prim: libcasm.configuration.Prim
            The prim, with symmetry information.

        clex_basis_specs: casm.bset.cluster_functions.ClexBasisSpecs
            Parameters specifying the cluster orbits and basis function type and order.

        prim_neighbor_list: PrimNeighborList
            The :class:`PrimNeighborList` is used to uniquely index sites with local
            variables included in the cluster functions, relative to a reference unit
            cell. If None, a default neighbor list is constructed.

        """
        cluster_specs = clex_basis_specs.cluster_specs
        bfunc_specs = clex_basis_specs.basis_function_specs

        clusters = [orbit[0] for orbit in cluster_specs.make_orbits()]

        orbit_branch_max_poly_order = {
            int(key): value
            for key, value in bfunc_specs.orbit_branch_max_poly_order.items()
        }

        phenomenal = cluster_specs.phenomenal()
        is_periodic = phenomenal is None

        occ_site_basis_functions_specs = None
        if "occ" in bfunc_specs.dof_specs:
            if "site_basis_functions" in bfunc_specs.dof_specs["occ"]:
                occ_site_basis_functions_specs = bfunc_specs.dof_specs["occ"][
                    "site_basis_functions"
                ]

        builder = ClusterFunctionsBuilder(
            prim=prim,
            generating_group=cluster_specs.generating_group(),
            dofs=bfunc_specs.dofs,
            clusters=clusters,
            phenomenal=cluster_specs.phenomenal(),
            global_max_poly_order=bfunc_specs.global_max_poly_order,
            orbit_branch_max_poly_order=orbit_branch_max_poly_order,
            occ_site_basis_functions_specs=occ_site_basis_functions_specs,
            prim_neighbor_list=prim_neighbor_list,
        )

        env = jinja2.Environment(
            trim_blocks=True,
            lstrip_blocks=True,
            loader=jinja2.PackageLoader("casm.bset"),
        )
        template = env.get_template(self.writer_type.template_name())

        ## common clexulator writer parameters
        writer_params = dict(
            project_name=self.project_name,
            bset_name=self.bset_name,
            is_periodic=is_periodic,
            prim_neighbor_list=builder.prim_neighbor_list,
            occ_site_functions=builder.occ_site_functions,
            linear_function_indices=self.linear_function_indices,
            cpp_fmt=self.cpp_fmt,
        )

        ## write periodic clexulator / prototype local clexulator
        writer = self.writer_type(
            i_clex=None,
            clusters=builder.clusters,
            functions=builder.functions,
            **writer_params,
        )
        self.src_path = self.bset_dir / f"{writer.clexulator_name}.cc"
        with open(self.src_path, "w") as f:
            f.write(template.render(writer.variables()))

        basis_path = self.bset_dir / "basis.json"

        with open(basis_path, "w") as f:
            data = builder.basis_dict(
                clex_basis_specs=clex_basis_specs,
                coordinate_mode="frac",
            )
            f.write(xtal.pretty_json(data))

        ## if local clexulators
        if phenomenal is not None:
            # write equivalents_info.json
            equivalents_info_path = self.bset_dir / "equivalents_info.json"
            with open(equivalents_info_path, "w") as f:
                f.write(xtal.pretty_json(builder.equivalents_info_dict()))

            # write each local clexulator
            self.local_src_path = []
            for i_clex in range(len(builder.equivalent_clusters)):
                writer = self.writer_type(
                    i_clex=i_clex,
                    clusters=builder.equivalent_clusters[i_clex],
                    functions=builder.equivalent_functions[i_clex],
                    **writer_params,
                )
                self.local_src_path.append(
                    self.bset_dir / f"{i_clex}" / f"{writer.clexulator_name}.cc"
                )
                self.local_src_path[-1].parent.mkdir(parents=True, exist_ok=True)
                with open(self.local_src_path[-1], "w") as f:
                    f.write(template.render(writer.variables()))

        return None
