"""Provides base classes for nodes in a data flow graph.

This module defines base classes for nodes in a data flow graph. It
includes a base configuration class (:class:`BaseNodeConfig`) and a
generic base class (:class:`BaseNode`) for defining nodes with
configurable input and output types.

Classes:
    - :class:`BaseNodeConfig`: Base configuration class for nodes in a data flow graph.
    - :class:`BaseNode`: Base class for nodes in a data flow graph.
    - :class:`IOContext`: Class providing context information for the I/O operations of data processors.
"""
from dataclasses import dataclass
from typing import Generic, TypeVar, overload

from datasets import Features

from hyped.base.config import BaseConfig, BaseConfigurable
from hyped.base.generic import solve_typevar

from ..refs.inputs import InputRefs, InputRefsContainer, InputRefsValidator
from ..refs.outputs import OutputRefs
from ..refs.ref import FeatureRef


@dataclass(frozen=True)
class IOContext:
    """Context information for the data processors execution.

    This class provides context for the input and output features during the data processing
    tasks. It holds the input and expected output features of the data processor call.

    Additionally, it serves as an identifier for the specific call to the processor within the
    data flow graph. This is particularly useful when a single processor class is used multiple
    times in a data flow, as :class:`IOContext` identifies the specific instance of the processor
    call, i.e., the specific node in the flow graph.
    """

    node_id: str
    """The id of the processor node in the data flow graph.

    This attribute serves as a unique identifier for the context, ensuring each processor
    call can be distinctly recognized within the flow graph.
    """

    inputs: None | Features
    """The input features for the data processor call.

    This attribute contains the features that are fed into the processor during execution.
    """

    outputs: Features
    """The output features expected to be generated by the data processor.

    This attribute defines the structure and types of features that the processor is 
    expected to produce as a result of its computation.
    """

    def __hash__(self) -> int:
        """Returns a hash value based on the node ID.

        Returns:
            int: The hash value of the node ID.
        """
        return hash(self.node_id)


class BaseNodeConfig(BaseConfig):
    """Base configuration class for nodes in a data flow graph."""


C = TypeVar("C", bound=BaseNodeConfig)
I = TypeVar("I", bound=None | InputRefs)
O = TypeVar("O", bound=OutputRefs)


class BaseNode(BaseConfigurable[C], Generic[C, I, O]):
    """Base class for nodes in a data flow graph.

    Attributes:
        _in_refs_type (Type[I]): The type of input references expected by the node.
        _out_refs_type (Type[O]): The type of output references produced by the node.
    """

    @classmethod
    @property
    def Config(self) -> type[C]:
        """Get the configuration type of the node."""
        return self.config_type

    def __init__(self, config: None | C = None, **kwargs) -> None:
        """Initialize the node with the given configuration.

        Args:
            config (None | C, optional): The configuration object for the node.
            **kwargs: Additional keyword arguments that update the provided configuration
                or create a new configuration if none is provided.
        """
        super(BaseNode, self).__init__(config, **kwargs)
        # get input and output reference types from typevars
        self._in_refs_type = solve_typevar(type(self), I)
        self._out_refs_type = solve_typevar(type(self), O)

        self._in_refs_validator: None | InputRefsValidator = None
        if self._in_refs_type is not type(None):
            # create input ref validator instance
            self._in_refs_validator = InputRefsValidator(
                self.config, self._in_refs_type
            )

    def __getstate__(self):
        """Prepare the state for serialization.

        Returns:
            dict: State dictionary containing only the config.
        """
        return {"config": self.config}

    def __setstate__(self, d):
        """Restore the state after deserialization.

        Args:
            d (dict): State dictionary.
        """
        self.__init__(config=d["config"])

    @property
    def required_input_keys(self) -> set[str]:
        """Retrieves the set of input keys required by the processor.

        Returns:
            set[str]: The set of input keys.
        """
        return (
            self._in_refs_validator.required_keys
            if self._in_refs_validator is not None
            else set()
        )

    @overload
    def call(self, **kwargs: FeatureRef) -> O:
        ...

    @overload
    def call(self, flow: object, **kwargs: FeatureRef) -> O:
        ...

    def call(self, flow: None | object = None, **kwargs: FeatureRef) -> O:
        """Adds the node to the data flow.

        This method first prepares the inputs, then adds the processor to the data
        flow and returns a feature reference to the output features of the processor.

        Args:
            flow (None | DataFlowGraph): The data flow graph to which to add the node. By default,
                the flow is inferred from the input references.
            **kwargs (FeatureRef): Keyword arguments specifying feature references to be passed
                as inputs to the processor.

        Returns:
            O: The output references produced by the processor.

        Raises:
            RuntimeError: If the flow cannot be inferred from the inputs and is not explicitly provided.
        """
        if (flow is None) and (len(kwargs) == 0):
            raise RuntimeError(
                "Flow cannot be inferred from the inputs and was not provided explicitly."
            )
        elif flow is None:
            # infer flow from first valid feature reference in inputs
            flow = next(iter(kwargs.values())).flow_

        inputs: None | InputRefsContainer = None
        # validate inputs in case validator is defined
        if self._in_refs_validator is not None:
            inputs = self._in_refs_validator.validate(**kwargs)
        # compute output features and add the processor to the data flow
        out_features = self._out_refs_type.build_features(
            self.config, None if inputs is None else inputs.named_refs
        )
        node_id = flow.add_processor_node(self, inputs, out_features)
        # return the output feature refs
        return self._out_refs_type(flow, node_id, out_features)
