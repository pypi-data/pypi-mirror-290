"""Jinja2 Template Data Processor."""
from functools import partial
from typing import Annotated

from datasets import Features, Value
from jinja2 import Environment, Template
from typing_extensions import Unpack

from hyped.common.lazy import LazyInstance
from hyped.data.flow.core.nodes.processor import (
    BaseDataProcessor,
    BaseDataProcessorConfig,
    IOContext,
    Sample,
)
from hyped.data.flow.core.refs.inputs import CheckFeatureEquals, InputRefs
from hyped.data.flow.core.refs.outputs import OutputFeature, OutputRefs
from hyped.data.flow.core.refs.ref import FeatureRef


class Jinja2InputRefs(InputRefs):
    """Input features for the Jinja2 Processor.

    In your template, access to the specific input feature values through the `values` variable. Specifically see
    the following example on how to access the respective values:

    .. code-block:: python

        valA = "The value of A is {{ inputs.A }}."
        featA = "The feature of B is {{ inputs['Name with whitespace'] }}."
    """

    features: Annotated[FeatureRef, CheckFeatureEquals(Features)]
    """The features that are accessable in the template. Access multiple
    features by collecting them. E.g.

    .. code-block:: python
    
        features = collect(...)
    """


class Jinja2OutputRefs(OutputRefs):
    """Output features generated by Jinja2 Processor."""

    rendered: Annotated[FeatureRef, OutputFeature(Value("string"))]
    """The rendered template."""


class Jinja2Config(BaseDataProcessorConfig):
    """Configuration for the Jinja2 processor."""

    template: str
    """The Jinja2 template to parse."""


def _setup_jinja_env(template_str: str) -> Template:
    """Helper function setting up the jinja environment."""
    # set up the jinja environment
    env = Environment(enable_async=True)
    # create template
    return env.from_string(template_str)


class Jinja2(
    BaseDataProcessor[
        Jinja2Config,
        Jinja2InputRefs,
        Jinja2OutputRefs,
    ]
):
    """Jinja2 Processor."""

    def __init__(self, config: None | Jinja2Config = None, **kwargs) -> None:
        """Instantiate a new Jinja2 Template Data Processor.

        Args:
            config (Jinja2Config): Config of the Jinja2 processor.
            **kwargs: Additional keyword arguments that update the provided configuration
                or create a new configuration if none is provided.
        """
        super(Jinja2, self).__init__(config, **kwargs)
        self.template = LazyInstance(
            partial(_setup_jinja_env, self.config.template)
        )

    async def process(
        self, inputs: Sample, index: int, rank: int, io: IOContext
    ) -> Sample:
        """Process example.

        Renders the template based on the given example and it's
        features.

        Args:
            inputs (Sample): Input sample containing features for template filling.
            index (int): Index of the sample in the dataset.
            rank (int): Rank of the sample.
            io (IOContext): Context information for the data processors execution.

        Returns:
            Sample: Output sample containing the rendered template string.
        """
        return Sample(
            rendered=await self.template.render_async(
                inputs=inputs["features"]
            )
        )

    def call(self, **kwargs: Unpack[Jinja2InputRefs]) -> Jinja2OutputRefs:
        """Execute the Jinja2 processor.

        Processes the input references to render a Jinja2 template based on the provided configuration
        and input features. Outputs the rendered template as a string.

        Args:
            features (FeatureRef): The features that are accessable in the template.
                This must reference a mapping feature where the keys in the mapping
                are valid keys in the jinja template.
            **kwargs (FeatureRef): Keyword arguments passed to call method.

        Returns:
            Jinja2OutputRefs: The output references containing the rendered template string.
        """
        return super(Jinja2, self).call(**kwargs)
